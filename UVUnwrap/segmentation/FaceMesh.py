"""
This file contains the FaceMesh class definition.

The FaceMesh is a container for the meshing information that is derived from the object, as well as any edge along which the individual face meshes should be fused together.
"""

__all__ = ["make_FaceMesh", "FaceMesh"]

# Official module imports
from functools import cached_property
import os
import math
import scipy as sp
import FreeCAD as App
import FreeCADGui as Gui
import MeshPart

# Local module imports
import UVUlib
from Exceptions import *
import dialogs
from .fuse_edge import fuse_edge
from .unlink_edge_nodes import unlink_edge_nodes


class FaceMesh():
    """
    An object that contains the generated mesh of one or more faces of a FreeCAD object.

    faces: list[tuple[str]] - A list of features to be included in the FaceMesh instance following the feature format generated by the selection lib.
    edges: list[tuple[str]] - A list of features to be included as Edges, either as splitters or as fusion edges, following the feature format generated by the selection lib.
    edge_mode: str - Any of ["Fuse", "Split"] - Determines whether the selected edges are treated as splits, with edges being fused by default, or seen as fuses with faces being independent by default.
    """
    def __init__(self, obj, faces: list[tuple[str]], edges: list[tuple[str]] = [], manualMeshParams: bool = False, linearDeflection: float = 5., angularDeflection: float = 10., relativeDeflection: bool = False):
        self.obj = obj
        obj.Proxy = self
        obj.addProperty("App::PropertyLinkSubListGlobal", "Faces", "Sources", "The faces included in this mesh")
        obj.addProperty("App::PropertyLinkSubListGlobal", "Edges", "Sources", "The edges along which the mesh is fused")
        obj.addProperty("App::PropertyBool", "ManualMeshParams", "Meshing", "Whether the mesh quality parameters are set manually").ManualMeshParams = manualMeshParams
        obj.addProperty("App::PropertyFloat", "LinearDeflection", "Meshing", "The maximum linear deflection of the generated mesh").LinearDeflection = linearDeflection
        obj.addProperty("App::PropertyFloat", "AngularDeflection", "Meshing", "The maximum linear deflection of the generated mesh").AngularDeflection = angularDeflection
        obj.addProperty("App::PropertyBool", "RelativeDeflection", "Meshing", "Whether the linear deflection value is relative to the respective edge length").RelativeDeflection = relativeDeflection
        obj.addProperty("App::PropertyBool", "CheckDuplicate", "Meshing", "Whether the FaceMesh should detect duplicated faces and edges in the selection during meshing. Disabling this can give a slight performance improvement.").CheckDuplicate = True
        self.init()
        self.set_selection(faces, edges)

    def init(self):
        """
        A function that initiates all relevant variables with empty / placeholder values.
        """
        # Book-keeping data:
        self.topo_faces = [] # A list of the TopoShape faces included in the mesh. Useful to limit the required recomputations by preventing repeated faces through indirect selections.
        self.topo_edges = [] # A list of the TopoShape edges included in the mesh. Useful to limit the required recomputations by preventing repeated edges through indirect selections.

        # Mesh data:
        self.vertices: list[App.Base.Vector] = []
        self.triangles: list[tuple[int]] = []

    def set_selection(self, faces: list[tuple[str]], edges: list[tuple[str]]):
        # TODO: Cleanup
        self.clear_selection()
        # Object construction:
        for face in faces:
            self.add_face(face)
        for edge in edges:
            self.add_edge(edge)
    def clear_selection(self):
        # TODO: Cleanup
        self.obj.Faces = []
        self.obj.Edges = []
        self.faces.clear()
        self.edges.clear()
        self.topo_faces.clear()
        self.topo_edges.clear()
        self.vertices.clear()
        self.triangles.clear()

    def execute(self, obj = None):
        """
        Recomputes the mesh created by / stored in this object.
        """
        # Clear the data of the previous recompute
        self.clear()
        # Recompute the mesh
        bodies = {UVUlib.link_to_feature(face[0]) for face in self.obj.Faces}
        for body in bodies:
            if self.obj.ManualMeshParams:
                MeshPart.meshFromShape(UVUlib.get_feature(body).Shape)
            else:
                MeshPart.meshFromShape(
                    Shape = UVUlib.get_feature(body).Shape,
                    LinearDeflection = self.obj.LinearDeflection,
                    AngularDeflection = math.radians(self.obj.AngularDeflection),
                    Relative = self.obj.RelativeDeflection
                    )

        # Update the FaceMesh object
        for feature in self.faces:
            for face in UVUlib.get_feature_faces(feature, implicit = True):
                self._add_face(face)
        for feature in self.edges:
            for edge in UVUlib.get_feature_edges(feature, implicit = True):
                self._add_edge(edge)

    def onChanged(self, obj, prop):
        return

    def add_face(self, feature: tuple[str]):
        """
        Adds the given feature to the FaceMesh' included faces.
        """
        if feature in self.faces:
            warn( RepeatedFeatureWarning("Face feature already exists in FaceMesh") )
            return
        self.faces.add(feature)
        self.obj.Faces += [(UVUlib.get_feature(feature[:2]), feature[2])]
        self.obj.touch()


    def _add_face(self, face: "OCCT::Face"):
        """
        Adds the mesh for the given toposhape face to the stored mesh data.
        """
        if self.obj.CheckDuplicate and any(face.isEqual(_face) for _face in self.topo_faces):
            warn( RepeatedFaceWarning("Cannot re-add an already added face to a FaceMesh object") )
            return
        self.topo_faces.append(face)
        # Get the existing face tessellation without creating a new tessellation
        vertices, triangles = face.tessellate(math.inf)
        UVNodes = face.getUVNodes()
        # Test if edge vertices are reused on multiple non-adjecent edges. If so, these should be separated.
        if len(vertices) != len(UVNodes):
            vertices, triangles = unlink_edge_nodes(face, vertices, UVNodes, triangles)

        # Remap the triangle / vertex indices
        vertex_offset = len(self.vertices)
        triangles = [tuple(i + vertex_offset for i in tri) for tri in triangles]

        self.vertices.extend(vertices)
        self.triangles.extend(triangles)

    def add_edge(self, feature: tuple[str]):
        """
        Adds the given feature to the FaceMesh' included edges.
        """
        if feature in self.edges:
            warn( RepeatedFeatureWarning("Edge feature already exists in FaceMesh") )
            return
        self.edges.add(feature)
        self.obj.Edges += [(UVUlib.get_feature(feature[:2]), feature[2])]
        self.obj.touch()

    def _add_edge(self, edge: "OCCT::Edge"):
        if self.obj.CheckDuplicate and any(edge.isEqual(_edge) for _edge in self.topo_edges):
            warn( RepeatedEdgeWarning("Cannot re-add an already added edge to a FaceMesh object") )
            return
        self.topo_edges.append(edge)
        # Apply the relevant transformations to the mesh data
        self.fuse_edge(edge)

    def fuse_edge(self, edge: "OCCT::Edge"):
        self.vertices, self.triangles = fuse_edge(self.vertices, self.triangles, edge)
        assert all(len(set(tri)) == 3 for tri in self.triangles)


    def merge_faceMesh(self, faceMesh):
        """
        Merges another FaceMesh into the current faceMesh.
        """
        raise NotImplementedError("FaceMesh merging is not yet implemented.")

    def clear(self):
        """
        Clears all reconstructable data from the object
        """
        self.topo_faces.clear()
        self.topo_edges.clear()
        self.vertices.clear()
        self.triangles.clear()

    def __getstate__(self):
        return {}
    def __setstate__(self, state):
        return

    def onDocumentRestored(self, obj):
        self.obj = obj
        self.obj.ViewObject.Proxy.obj = self.obj.ViewObject
        self.init()
        self.execute()

    # The following properties are implemented as cached properties to allow for
    # these to be correctly set for objects loaded from a file. This includes
    # being able to make use of the internal saving/loading mechanism that
    # updates the filename of the current file if it was changed, e.g. due to
    # the file still being unnamed when it was first created.
    @cached_property
    def faces(self) -> set:
        faces = set()
        for feature in self.obj.Faces:
            faces |= {(*feature[0].FullName.split("#"), element) for element in feature[1]}
        return faces
    @cached_property
    def edges(self) -> set:
        edges = set()
        for feature in self.obj.Edges:
            edges |= {(*feature[0].FullName.split("#"), element) for element in feature[1]}
        return edges

    @property
    def area(self):
        """
        The area of the toposhape faces included in the FaceMesh.
        """
        return sum(face.Area for face in self.topo_faces)
    @property
    def mesh_area(self):
        """
        The area of the meshed representation of the faces included in the FaceMesh.
        """
        return sum((self.vertices[triangle[1]]-self.vertices[triangle[0]]).cross(self.vertices[triangle[2]]-self.vertices[triangle[0]]).Length \
                   for triangle in self.triangles) / 2

# Testing GUI stuff
class FaceMeshVP():
    def __init__(self, obj):
        obj.Proxy = self
        self.obj = obj

    def getIcon(self):
        return os.path.join(UVUlib.path_icons, "FaceMesh.svg")

    def setEdit(self, obj, edit_mode):
        if edit_mode == 0:
            taskDialog = dialogs.FaceMeshDialog(obj.Object.Proxy)
            Gui.Control.showDialog(taskDialog)
            return True

    def __getstate__(self):
        return {}
    def __setstate__(self, state):
        return

def make_FaceMesh(faces: list[tuple[str]] = [], edges: list[tuple[str]] = [], manualMeshParams: bool = False, linearDeflection: float = 5., angularDeflection: float = 10., relativeDeflection: bool = False):
    obj = App.ActiveDocument.addObject("Part::FeaturePython", "FaceMesh")
    faceMesh = FaceMesh(obj, faces, edges, manualMeshParams, linearDeflection, angularDeflection, relativeDeflection)
    faceMeshVP = FaceMeshVP(obj.ViewObject)
    App.ActiveDocument.recompute()
    return obj

def update_FaceMesh(faceMesh, faces: list[tuple[str]] = [], edges: list[tuple[str]] = [], manualMeshParams: bool = False, linearDeflection: float = 5., angularDeflection: float = 10., relativeDeflection: bool = False):
    faceMesh.set_selection(faces, edges)
    faceMesh.obj.ManualMeshParams = manualMeshParams
    faceMesh.obj.LinearDeflection = linearDeflection
    faceMesh.obj.AngularDeflection = angularDeflection
    faceMesh.obj.RelativeDeflection = relativeDeflection
